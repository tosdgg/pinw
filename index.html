<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelike 試算表彈珠台</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        
        /* UI 層 */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        h1 { margin: 0; font-size: 24px; color: #f1c40f; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .stat { font-size: 18px; margin-top: 5px; }

        /* Roguelike 選擇選單 */
        #rogue-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none; /* 預設隱藏 */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #rogue-overlay.active { display: flex; }
        
        .card-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .buff-card {
            background: #2c3e50;
            border: 2px solid #34495e;
            border-radius: 10px;
            padding: 20px;
            width: 200px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .buff-card:hover {
            transform: translateY(-10px);
            background: #34495e;
            border-color: #f1c40f;
        }
        .buff-title { font-size: 20px; font-weight: bold; color: #f1c40f; margin-bottom: 10px; }
        .buff-desc { font-size: 14px; color: #bdc3c7; line-height: 1.4; }

        #start-msg {
            position: absolute;
            bottom: 100px;
            color: #7f8c8d;
            animation: pulse 2s infinite;
            pointer-events: none;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        
        canvas { border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>ROGUELIKE PINBALL</h1>
        <div class="stat">分數: <span id="score">0</span></div>
        <div class="stat">目前球數: <span id="ball-count">0</span></div>
        <div class="stat" style="font-size: 14px; color: #7f8c8d; margin-top: 10px;">現有 Buff: <span id="buff-list">無</span></div>
    </div>

    <div id="start-msg">點擊畫面開始遊戲</div>

    <div id="rogue-overlay">
        <h2 style="font-size: 32px; color: white;">回合結束！選擇強化</h2>
        <div class="card-container" id="card-container">
            </div>
    </div>

    <script>
        // --- 1. 設定與變數 ---
        const CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTO5nwKqK0iYAzeMKhQgUHEN3FSrcMDzYxgclXwAu5dAH0Bcx_lBd9_olSw8JTT_s354u1i_rqonZwF/pub?output=csv';
        
        let score = 0;
        let gameActive = false; // 是否在進行中
        let ballsInPlay = 0;
        
        // 玩家目前的屬性 (可被 Buff 修改)
        const playerStats = {
            ballSize: 10,
            restitution: 0.8, // 彈性
            gravityScale: 1,  // 重力倍率
            multiBall: 1,     // 每次生成幾顆球
            scoreMultiplier: 1,
            color: '#e74c3c'
        };

        const activeBuffs = []; // 紀錄已獲得的 Buff 名稱

        // --- 2. 物理引擎初始化 ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body;

        const engine = Engine.create();
        const world = engine.world;
        const width = 800;
        const height = 600;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: { width, height, wireframes: false, background: '#222' }
        });

        // 邊界
        const floor = Bodies.rectangle(width/2, height + 100, width, 200, { isStatic: true, label: 'floor' });
        const walls = [
            floor,
            Bodies.rectangle(-30, height/2, 60, height * 2, { isStatic: true }),
            Bodies.rectangle(width + 30, height/2, 60, height * 2, { isStatic: true })
        ];
        Composite.add(world, walls);

        // --- 3. 遊戲邏輯 ---

        // 讀取 CSV 生成釘子
        function loadPins() {
            Papa.parse(CSV_URL, {
                download: true,
                header: true,
                dynamicTyping: true,
                complete: function(results) {
                    const pins = [];
                    results.data.forEach(row => {
                        if (row.x && row.y) {
                            const size = row.size || 15;
                            // 根據 size 稍微改變顏色
                            const color = size > 15 ? '#e67e22' : '#f1c40f'; 
                            
                            const pin = Bodies.circle(row.x, row.y, size, {
                                isStatic: true,
                                label: 'pin',
                                render: { fillStyle: color }
                            });
                            pins.push(pin);
                        }
                    });
                    Composite.add(world, pins);
                    console.log(`Loaded ${pins.length} pins from Google Sheet`);
                }
            });
        }

        // 生成彈珠 (根據 playerStats)
        function spawnBalls(x, y) {
            if (ballsInPlay > 0) return; // 防止重複生成
            
            gameActive = true;
            document.getElementById('start-msg').style.display = 'none';

            // 根據 multiBall 屬性決定生成幾顆
            for (let i = 0; i < playerStats.multiBall; i++) {
                setTimeout(() => {
                    const offset = (i - playerStats.multiBall/2) * 20;
                    const ball = Bodies.circle(x + offset, y, playerStats.ballSize, {
                        restitution: playerStats.restitution,
                        label: 'ball',
                        render: { fillStyle: playerStats.color }
                    });
                    
                    // 應用重力縮放 (這需要每幀更新，這裡先用簡單的力模擬初始狀態，MatterJS改重力通常是全域的，但我們可以改空氣阻力或質量來模擬)
                    // 為了簡單實現"低重力"，我們調整引擎全域重力，但在多人模式下這會影響所有球。
                    // 這裡我們採用標準物理。
                    
                    Composite.add(world, ball);
                    ballsInPlay++;
                    updateUI();
                }, i * 100);
            }
        }

        // 碰撞偵測 (得分)
        Events.on(engine, 'collisionStart', function(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;

                // 檢查是否是球撞到釘子
                if ((bodyA.label === 'ball' && bodyB.label === 'pin') || 
                    (bodyB.label === 'ball' && bodyA.label === 'pin')) {
                    
                    // 增加分數
                    score += 10 * playerStats.scoreMultiplier;
                    updateUI();
                    
                    // 視覺效果：撞到的釘子閃一下
                    const pin = bodyA.label === 'pin' ? bodyA : bodyB;
                    pin.render.fillStyle = '#fff';
                    setTimeout(() => { pin.render.fillStyle = '#f1c40f'; }, 100);
                }
            });
        });

        // 檢測球是否掉落 (回合結束判定)
        Events.on(engine, 'collisionStart', function(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                // 球撞到地板
                if ((bodyA = pair.bodyA).label === 'floor' || (bodyB = pair.bodyB).label === 'floor') {
                    const ball = bodyA.label === 'ball' ? bodyA : bodyB;
                    
                    // 移除球
                    Composite.remove(world, ball);
                    ballsInPlay--;
                    updateUI();

                    // 如果所有球都沒了，觸發 Roguelike 選單
                    if (ballsInPlay <= 0 && gameActive) {
                        gameActive = false;
                        showRoguelikeMenu();
                    }
                }
            });
        });

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('ball-count').innerText = ballsInPlay;
        }

        // --- 4. Roguelike 系統 ---

        // Buff 資料庫
        const buffLibrary = [
            { id: 1, name: "巨型核心", desc: "彈珠半徑 +50%", effect: () => { playerStats.ballSize *= 1.5; } },
            { id: 2, name: "橡膠塗層", desc: "彈性大幅增加 (更會彈)", effect: () => { playerStats.restitution = Math.min(1.2, playerStats.restitution + 0.2); } },
            { id: 3, name: "多重影分身", desc: "每次發射多 +1 顆球", effect: () => { playerStats.multiBall += 1; } },
            { id: 4, name: "黃金球拍", desc: "分數獲取 x2", effect: () => { playerStats.scoreMultiplier *= 2; playerStats.color = '#f39c12'; } },
            { id: 5, name: "月球漫步", desc: "全域重力減半", effect: () => { engine.gravity.y *= 0.7; activeBuffs.push("低重力"); } },
            { id: 6, name: "奈米球群", desc: "球變很小，但一次 +3 顆", effect: () => { playerStats.ballSize *= 0.6; playerStats.multiBall += 3; } }
        ];

        function showRoguelikeMenu() {
            const overlay = document.getElementById('rogue-overlay');
            const container = document.getElementById('card-container');
            container.innerHTML = ''; // 清空舊卡片

            // 隨機選 3 個 buff
            const options = [];
            const tempLib = [...buffLibrary]; // 複製一份
            for(let i=0; i<3; i++) {
                if(tempLib.length === 0) break;
                const randIndex = Math.floor(Math.random() * tempLib.length);
                options.push(tempLib[randIndex]);
                tempLib.splice(randIndex, 1); // 避免重複選到同一個
            }

            // 生成 HTML
            options.forEach(buff => {
                const card = document.createElement('div');
                card.className = 'buff-card';
                card.innerHTML = `
                    <div class="buff-title">${buff.name}</div>
                    <div class="buff-desc">${buff.desc}</div>
                `;
                card.onclick = () => selectBuff(buff);
                container.appendChild(card);
            });

            overlay.classList.add('active');
        }

        function selectBuff(buff) {
            // 應用效果
            buff.effect();
            activeBuffs.push(buff.name);
            document.getElementById('buff-list').innerText = activeBuffs.join(', ');

            // 隱藏選單
            document.getElementById('rogue-overlay').classList.remove('active');
            
            // 提示玩家再次點擊
            document.getElementById('start-msg').innerText = "點擊畫面發射下一輪";
            document.getElementById('start-msg').style.display = 'block';
        }

        // --- 5. 啟動 ---
        loadPins();
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // 點擊觸發 (僅在遊戲非進行中且選單關閉時有效)
        render.canvas.addEventListener('mousedown', (event) => {
            if (!gameActive && ballsInPlay === 0 && !document.getElementById('rogue-overlay').classList.contains('active')) {
                const rect = render.canvas.getBoundingClientRect();
                // 限制生成位置在上方
                spawnBalls(rect.width / 2, 50); 
            }
        });

    </script>
</body>
</html>
